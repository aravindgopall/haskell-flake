# Definition of the `haskellProjects.${name}` submodule's `config`
project@{ name, lib, pkgs, ... }:
let
  inherit (lib)
    types;

  packageSubmodule = import ./package.nix { inherit project lib pkgs; };

  # Merge the list of attrset of modules.
  mergeModuleAttrs =
    lib.zipAttrsWith (k: vs: { imports = vs; });

  tracePackages = k: x:
    project.config.log.traceDebug "${k} ${builtins.toJSON x}" x;

  generateNix = name: source:
    let
      self = project.config.basePackages;
      callCabal2nixWithOptionsExr = name: src: extraCabal2nixOptions:
        let
          filter = path: type:
            pkgs.lib.hasSuffix ".cabal" path ||
            baseNameOf path == "package.yaml";
        in
        self.haskellSrc2nix {
          inherit name extraCabal2nixOptions;
          src =
            if pkgs.lib.canCleanSource src
            then pkgs.lib.cleanSourceWith { inherit src filter; }
            else src;
        };
      readCabal2NixExpr = drv:
        project.config.log.traceDebug "using IFD: ${drv.outPath}" "${drv}/default.nix";
    in
    readCabal2NixExpr (if lib.types.path.check source
    then callCabal2nixWithOptionsExr name source ""
    else self.hackage2nix name source);

in
{
  options = {
    packages = lib.mkOption {
      type = types.lazyAttrsOf types.deferredModule;
      default = { };
      apply = packages:
        let
          packages' =
            # Merge user-provided 'packages' with 'defaults.packages'. 
            #
            # Note that the user can override the latter too if they wish.
            mergeModuleAttrs
              [ project.config.defaults.packages packages ];
        in
        tracePackages "${name}.packages:apply" (
          lib.mapAttrs
            (name: v:
              (lib.evalModules {
                modules = [ packageSubmodule v ];
                specialArgs = { inherit name pkgs; };
              }).config
            )
            packages');

      description = ''
        Additional packages to add to `basePackages`.

        Local packages are added automatically (see `config.defaults.packages`):

        You can also override the source for existing packages here.
      '';
    };

    packagesOverlay = lib.mkOption {
      type = import ../../../types/haskell-overlay-type.nix { inherit lib; };
      description = ''
        The Haskell overlay computed from `packages` modules.
      '';
      internal = true;
      default = self: _super:
        let
          inherit (project.config) log;
          build-haskell-package = import ../../../build-haskell-package.nix {
            inherit pkgs lib self log;
          };
          callPackageKeepDeriver = src: args:
            pkgs.haskell.lib.compose.overrideCabal
              (orig: {
                passthru = orig.passthru or { } // {
                  # When using callCabal2nix or callHackage, it is often useful
                  # to debug a failure by inspecting the Nix expression
                  # generated by cabal2nix. This can be accessed via this
                  # cabal2nixDeriver field.
                  cabal2nixDeriver = src;
                };
              })
              (self.callPackage src args);
          getOrMkPackage = name: cfg:
            let
              x =
                if builtins.pathExists "${project.config.projectRoot}/.haskellSrc2nix"
                then { filePath = "${project.config.projectRoot}/.haskellSrc2nix/${name}.nix"; args = { src = cfg.source; }; }
                else { filePath = generateNix name cfg.source; args = { }; };
            in
            if lib.types.path.check cfg.source
            then
              log.traceDebug "${name}.callCabal2nix[cached] ${cfg.source}"
                (build-haskell-package name cfg.source x.filePath x.args)
            else
              log.traceDebug
                (if args == { }
                then "${name}.callHackage ${cfg.source}"
                else "${name}.callHackage[cached] ${cfg.source}"
                )
                (callPackageKeepDeriver x.filePath x.args);
        in
        lib.mapAttrs getOrMkPackage (log.traceDebug "${builtins.toJSON (lib.attrNames project.config.packages)}" project.config.packages);
    };

    # cabal2nix generated Nix expressions for packages
    # uses `hackage2nix`
    packagesNix = lib.mkOption {
      default =
        lib.mapAttrs
          (name: cfg: generateNix name cfg.source)
          project.config.packages;
    };
  };
}
